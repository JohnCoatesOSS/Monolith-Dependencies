.\" dpkg manual page - dpkg-gensymbols(1)
.\"
.\" Copyright Â© 2007-2011 RaphaÃ«l Hertzog <hertzog@debian.org>
.\" Copyright Â© 2009-2010 Modestas Vainius <modestas@vainius.eu>
.\" Copyright Â© 2012-2015 Guillem Jover <guillem@debian.org>
.\"
.\" This is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2 of the License, or
.\" (at your option) any later version.
.\"
.\" This is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program.  If not, see <https://www.gnu.org/licenses/>.
.
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH dpkg\-gensymbols 1 2014\-12\-29 "Projekt Debian" "programy pomocnicze dpkg"
.SH NAZWA
dpkg\-gensymbols \- generuje pliki symboli (informacje o zale¿no¶ciach
bibliotek wspó³dzielonych)
.
.SH SK£ADNIA
\fBdpkg\-gensymbols\fP [\fIopcja\fP...]
.
.SH OPIS
\fBdpkg\-gensymbols\fP skanuje tymczasowe drzewo budowania (domy¶lnie
debian/tmp) w poszukiwaniu bibliotek i generuje opisuj±cy je plik
\fIsymbols\fP. Plik ten, je¶li nie jest pusty, jest nastêpnie instalowany do
podkatalogu DEBIAN drzewa budowania, tak wiêc na koñcu zawiera informacje
kontrolne pakietu.
.P
Podczas tworzenia wspomnianych plików, jako wej¶cie s± u¿ywane pliki symboli
dostarczone przez opiekuna. Szukane s± nastêpuj±ce pliki (u¿ywany jest
pierwszy ze znalezionych):
.IP \(bu 4
debian/\fIpakiet\fP.symbols.\fIarch\fP
.IP \(bu 4
debian/symbols.\fIarch\fP
.IP \(bu 4
debian/\fIpakiet\fP.symbols
.IP \(bu 4
debian/symbols
.P
The main interest of those files is to provide the minimal version
associated to each symbol provided by the libraries. Usually it corresponds
to the first version of that package that provided the symbol, but it can be
manually incremented by the maintainer if the ABI of the symbol is extended
without breaking backwards compatibility. It's the responsibility of the
maintainer to keep those files up\-to\-date and accurate, but
\fBdpkg\-gensymbols\fP helps with that.
.P
Gdy wygenerowane pliki symboli ró¿ni± siê od dostarczonych przez opiekuna,
\fBdpkg\-gensymbols\fP wypisze ró¿nicê pomiêdzy dwoma wersjami. Co wiêcej, je¶li
ró¿nica jest zbyt du¿a, zakoñczy siê niepowodzeniem (mo¿na dostosowaæ
wielko¶æ tolerowanej ró¿nicy, patrz opcja \fB\-c\fP).
.SH "ZARZ¡DZANIE PLIKAMI SYMBOLI"
The symbols files are really useful only if they reflect the evolution of
the package through several releases. Thus the maintainer has to update them
every time that a new symbol is added so that its associated minimal version
matches reality.  The diffs contained in the build logs can be used as a
starting point, but the maintainer, additionally, has to make sure that the
behaviour of those symbols has not changed in a way that would make anything
using those symbols and linking against the new version, stop working with
the old version.  In most cases, the diff applies directly to the
debian/\fIpackage\fP.symbols file. That said, further tweaks are usually
needed: it's recommended for example to drop the Debian revision from the
minimal version so that backports with a lower version number but the same
upstream version still satisfy the generated dependencies.  If the Debian
revision can't be dropped because the symbol really got added by the Debian
specific change, then one should suffix the version with \(oq\fB~\fP\(cq.
.P
Przed dodaniem jakiejkolwiek ³atki do pliku symboli, opiekun powinien dwa
razy sprawdziæ, czy jest ona poprawna. Publiczne symbole nie mog± znikaæ,
wiêc najlepiej je¶li jedynie dodaje ona nowe wiersze.
.P
Note that you can put comments in symbols files: any line with \(oq#\(cq as
the first character is a comment except if it starts with \(oq#include\(cq
(see section \fBUsing includes\fP).  Lines starting with \(oq#MISSING:\(cq are
special comments documenting symbols that have disappeared.
.P
Do not forget to check if old symbol versions need to be increased.  There
is no way \fBdpkg\-gensymbols\fP can warn about this. Blindly applying the diff
or assuming there is nothing to change if there is no diff, without checking
for such changes, can lead to packages with loose dependencies that claim
they can work with older packages they cannot work with. This will introduce
hard to find bugs with (partial)  upgrades.
.SS "U¿ywanie podstawieñ #PACKAGE#"
.P
W niektórych rzadkich przypadkach, nazwa biblioteki ró¿ni siê miêdzy
architekturami. Aby zapobiec kodowaniu nazwy pakietu na sztywno w pliku
symboli, mo¿na u¿yæ markera \fI#PACKAGE#\fP. Zostanie ona zast±piona prawdziw±
nazw± pakietu podczas instalacji tych plików symboli. W przeciwieñstwie do
markera \fI#MINVER#\fP, \fI#PACKAGE#\fP nigdy nie pojawi siê w pliku symboli
wewn±trz pakietu binarnego.
.SS "U¿ywanie znaczników symboli"
.P
Symbol tagging is useful for marking symbols that are special in some way.
Any symbol can have an arbitrary number of tags associated with it. While
all tags are parsed and stored, only some of them are understood by
\fBdpkg\-gensymbols\fP and trigger special handling of the symbols. See
subsection \fBStandard symbol tags\fP for reference of these tags.
.P
Okre¶lenie znacznika powinno znale¼æ siê zaraz przed nazw± symbolu (nie ma
pomiêdzy nimi spacji). Zawsze rozpoczyna siê nawiasem otwieraj±cym \fB(\fP,
koñczy nawiasem zamykaj±cym \fB)\fP i musi zawieraæ przynajmniej jeden
znacznik. Poszczególne znaczniki s± oddzielone znakiem \fB|\fP. Ka¿dy znacznik
mo¿e posiadaæ warto¶æ (opcjonalnie), która jest oddzielona od jego nazwy za
pomoc± znaku \fB=\fP. Nazwy i warto¶ci znaczników mog± zawieraæ dowolne znaki,
poza znakami specjalnymi \fB)\fP \fB|\fP \fB=\fP. Nazwy symboli, które znajduj± siê
za okre¶leniem znacznika, mog± zostaæ opcjonalnie ujête w znaki \fB'\fP lub
\fB"\fP. Jednak je¶li symbol nie okre¶la ¿adnych znaczników, cudzys³owy s±
traktowane jako czê¶æ nazwy symbolu, która koñczy siê na pierwszej spacji.
.P
 (tag1=i am marked|tag name with space)"tagged quoted symbol"@Base 1.0
 (optional)tagged_unquoted_symbol@Base 1.0 1
 untagged_symbol@Base 1.0
.P
Pierwszy symbol w przyk³adzie jest nazwany \fItagged quoted symbol\fP i posiada
dwa znaczniki \fItag1\fP z warto¶ci± \fIi am marked\fP i \fItag name with space\fP,
który nie posiada warto¶ci. Drugi symbol ma nazwê \fItagged_unquoted_symbol\fP
jest jego jedynym znacznikiem jest \fIoptional\fP. Ostatni symbol jest
przyk³adem zwyk³ego symbolu bez znacznika.
.P
Since symbol tags are an extension of the \fBdeb\-symbols\fP(5) format, they can
only be part of the symbols files used in source packages (those files
should then be seen as templates used to build the symbols files that are
embedded in binary packages). When \fBdpkg\-gensymbols\fP is called without the
\fB\-t\fP option, it will output symbols files compatible to the
\fBdeb\-symbols\fP(5) format: it fully processes symbols according to the
requirements of their standard tags and strips all tags from the output. On
the contrary, in template mode (\fB\-t\fP) all symbols and their tags (both
standard and unknown ones)  are kept in the output and are written in their
original form as they were loaded.
.SS "Standardowe znaczniki symboli"
.TP 
\fBoptional\fP
A symbol marked as optional can disappear from the library at any time and
that will never cause \fBdpkg\-gensymbols\fP to fail. However, disappeared
optional symbols will continuously appear as MISSING in the diff in each new
package revision.  This behaviour serves as a reminder for the maintainer
that such a symbol needs to be removed from the symbol file or readded to
the library. When the optional symbol, which was previously declared as
MISSING, suddenly reappears in the next revision, it will be upgraded back
to the \(lqexisting\(rq status with its minimum version unchanged.

Znacznik ten jest przydatny do symboli prywatnych, gdy ich znikniêcie nie
spowoduje z³amania ABI. Przyk³adowo, wiêkszo¶æ szablonów C++ nale¿y do tej
kategorii. Podobnie jak ka¿dy inny znacznik, mo¿e mieæ on równie¿ dowoln±
warto¶æ: mo¿na jej u¿yæ do okre¶lenia powodu, dla którego symbol jest
opcjonalny.
.TP 
\fBarch=\fP\fIarchitecture\-list\fP
.TQ
\fBarch\-bits=\fP\fIarchitecture\-bits\fP
.TQ
\fBarch\-endian=\fP\fIarchitecture\-endianness\fP
These tags allow one to restrict the set of architectures where the symbol
is supposed to exist. The \fBarch\-bits\fP and \fBarch\-endian\fP tags are supported
since dpkg 1.18.0. When the symbols list is updated with the symbols
discovered in the library, all arch\-specific symbols which do not concern
the current host architecture are treated as if they did not exist. If an
arch\-specific symbol matching the current host architecture does not exist
in the library, normal procedures for missing symbols apply and it may cause
\fBdpkg\-gensymbols\fP to fail. On the other hand, if the arch\-specific symbol
is found when it was not supposed to exist (because the current host
architecture is not listed in the tag or does not match the endianness and
bits), it is made arch neutral (i.e. the arch, arch\-bits and arch\-endian
tags are dropped and the symbol will appear in the diff due to this change),
but it is not considered as new.

Podczas dzia³ania w domy¶lnym trybie nieszablonowym, spo¶ród symboli
specyficznych dla architektury tylko te, które pasuj± do architektury
bie¿±cego komputera s± zapisywane do pliku symboli. Odwrotnie jest w trybie
szablonu: wszystkie symbole specyficzne dla architektury (³±cznie z tymi,
nale¿±cymi do obcych architektur) s± zawsze zapisywane do pliku symboli.

The format of \fIarchitecture\-list\fP is the same as the one used in the
\fBBuild\-Depends\fP field of \fIdebian/control\fP (except the enclosing square
brackets []). For example, the first symbol from the list below will be
considered only on alpha, any\-amd64 and ia64 architectures, the second only
on linux architectures, while the third one anywhere except on armel.

 (arch=alpha any\-amd64 ia64)a_64bit_specific_symbol@Base 1.0
 (arch=linux\-any)linux_specific_symbol@Base 1.0
 (arch=!armel)symbol_armel_does_not_have@Base 1.0

The \fIarchitecture\-bits\fP is either \fB32\fP or \fB64\fP.

 (arch\-bits=32)a_32bit_specific_symbol@Base 1.0
 (arch\-bits=64)a_64bit_specific_symbol@Base 1.0

The \fIarchitecture\-endianness\fP is either \fBlittle\fP or \fBbig\fP.

 (arch\-endian=little)a_little_endian_specific_symbol@Base 1.0
 (arch\-endian=big)a_big_endian_specific_symbol@Base 1.0

Multiple restrictions can be chained.

 (arch\-bits=32|arch\-endian=little)a_32bit_le_symbol@Base 1.0
.TP 
\fBignore\-blacklist\fP
dpkg\-gensymbols posiada wewnêtrzn±, czarn± listê symboli, które nie powinny
pojawiæ siê w plikach symboli, poniewa¿ s± one z regu³y jedynie efektem
ubocznym detali implementacyjnych toolchainu. Je¶li z jakiego¶ powodu
naprawdê chce siê w³±czyæ jeden z tych symboli do pliku symboli, nale¿y
oznaczyæ ten symbol znacznikiem \fBignore\-blacklist\fP. Mo¿e byæ potrzebny do
niektórych niskopoziomowych bibliotek toolchainu, takich jak libgcc.
.TP 
\fBc++\fP
Oznacza wzorzec symbolu \fIc++\fP. Patrz podsekcja \fBU¿ywanie wzorców symboli\fP
poni¿ej.
.TP 
\fBsymver\fP
Oznacza wzorzec symbolu \fIsymver\fP (wersja symbolu). Patrz podsekcja
\fBU¿ywanie wzorców symboli\fP poni¿ej.
.TP 
\fBregex\fP
Oznacza wzorzec symbolu \fIregex\fP. Patrz podsekcja \fBU¿ywanie wzorców
symboli\fP poni¿ej.
.SS "U¿ywanie wzorców symboli"
.P
W przeciwieñstwie do standardowej specyfikacji symboli, wzorzec mo¿e
pokrywaæ wiele symboli rzeczywistych z biblioteki. \fBdpkg\-gensymbols\fP
postara siê dopasowaæ ka¿dy wzorzec do ka¿dego symbolu rzeczywistego, który
\fInie\fP posiada zdefiniowanego odpowiedniego symbolu specyficznego w pliku
symboli. Gdy tylko znaleziony zostanie pierwszy pasuj±cy wzorzec, to
wszystkie jego znaczniki i w³a¶ciwo¶ci bêd± u¿ywane jako podstawa okre¶lenia
symbolu. Je¶li ¿aden ze wzorców nie zostanie dopasowany, to symbol zostanie
uznany za nowy.

A pattern is considered lost if it does not match any symbol in the
library. By default this will trigger a \fBdpkg\-gensymbols\fP failure under
\fB\-c1\fP or higher level. However, if the failure is undesired, the pattern
may be marked with the \fIoptional\fP tag. Then if the pattern does not match
anything, it will only appear in the diff as MISSING. Moreover, like any
symbol, the pattern may be limited to the specific architectures with the
\fIarch\fP tag. Please refer to \fBStandard symbol tags\fP subsection above for
more information.

Patterns are an extension of the \fBdeb\-symbols\fP(5) format hence they are
only valid in symbol file templates. Pattern specification syntax is not any
different from the one of a specific symbol. However, symbol name part of
the specification serves as an expression to be matched against
\fIname@version\fP of the real symbol. In order to distinguish among different
pattern types, a pattern will typically be tagged with a special tag.

Obecnie \fBdpkg\-gensymbols\fP obs³uguje trzy proste typy symboli:
.TP  3
\fBc++\fP
Ten wzorzec jest oznaczony znacznikiem \fIc++\fP. Dopasowuje on jedynie symbole
C++ za pomoc± ich odkodowanych nazw symboli (takich, jak wypisywanych przez
narzêdzie \fBc++filt\fP(1)). Wzorzec jest bardzo przydatny do dopasowania
symboli, których zakodowane nazwy mog± ró¿niæ siê miêdzy ró¿nymi
architekturami, podczas gdy odkodowane nazwy pozostaj± takie same. Jedn± z
grup takich symboli jest \fInon\-virtual thunks\fP, które posiadaj± przesuniêcia
(offsety) specyficzne dla architektury, do³±czone do zakodowanych
nazw. Czêstym przypadkiem tego przyk³adu jest wirtualny destruktor, który w
wirtualnym dziedziczeniu (ang. diamond inheritance) wymaga niewirtualnego
symbolu thunk. Na przyk³ad nawet je¶li _ZThn8_N3NSB6ClassDD1Ev@Base na
architekturze 32\-bitowej stanie siê prawdopodobnie
_ZThn16_N3NSB6ClassDD1Ev@Base na 64\-bitowej, mo¿e zostaæ dopasowany
pojedynczym wzorcem \fIc++\fP:
.RS
.PP
libdummy.so.1 libdummy1 #MINVER#
 [...]
 (c++)"non\-virtual thunk to NSB::ClassD::~ClassD()@Base" 1.0
 [...]
.P
Powy¿sz±, odkodowan± nazwê mo¿na uzyskaæ wykonuj±c nastêpuj±ce polecenie:
.PP
 $ echo '_ZThn8_N3NSB6ClassDD1Ev@Base' | c++filt
.P
Proszê zauwa¿yæ, ¿e o ile zakodowana nazwa jest, z definicji, unikatowa w
bibliotece, o tyle nie musi byæ to prawd± dla nazw odkodowanych. Kilka
ró¿ni±cych siê symboli rzeczywistych mo¿e mieæ tê sam± nazwê odkodowan±. Na
przyk³ad dzieje siê tak w przypadku niewirtualnych symboli thunk w z³o¿onych
konfiguracjach dziedziczenia lub w przypadku wiêkszo¶ci konstruktorów i
desktruktorów (poniewa¿ g++ tworzy dla nich z regu³y dwa symbole
rzeczywiste). Jednak, poniewa¿ konflikty zachodz± na poziomie ABI, nie
powinny one obni¿yæ jako¶ci pliku symboli.
.RE
.TP 
\fBsymver\fP
Wzorzec jest oznaczany znacznikiem \fIsymver\fP. Dobrze zarz±dzane biblioteki
posiadaj± wersjonowane symbole, a ka¿da wersja odpowiada wersji oryginalnej,
gdzie symbol zosta³ dodany. W takim przypadku mo¿na u¿yæ wzorca \fIsymver\fP,
aby dopasowaæ symbol zwi±zany z okre¶lon± wersj± np.:
.RS
.PP
libc.so.6 libc6 #MINVER#
 (symver)GLIBC_2.0 2.0
 [...]
 (symver)GLIBC_2.7 2.7
 access@GLIBC_2.0 2.2
.PP
Wszystkie symbole zwi±zane z wersjami GLIBC_2.0 i GLIBC_2.7 prowadz± do,
odpowiednio, minimalnej wersji 2.0 i 2.7 z wyj±tkiem symbolu
access@GLIBC_2.0. Ostatnie, prowadzi do minimalnej zale¿no¶ci na libc6 w
wersji 2.2 pomimo, ¿e znajduje siê w zakresie wzorca "(symver)GLIBC_2.0",
poniewa¿ specyficzne symbole maj± pierwszeñstwo przed wzorcami.
.P
Proszê zauwa¿yæ, ¿e o ile wzorca masek starego stylu (oznaczane przez
"*@version" w polu nazwy symbolu s± wci±¿ obs³ugiwane, to s± obecnie
zast±pione przez now± sk³adniê "(symver|optional)version". Na przyk³ad
"*@GLIBC_2.0 2.0" powinno byæ zapisane jako "(symver|optional)GLIBC_2.0
2.0", je¶li potrzebne jest takie samo znaczenie.
.RE
.TP 
\fBregex\fP
Wyra¿enia regularne s± oznaczane znacznikiem \fIregex\fP. S± dopasowane za
pomoc± wyra¿eñ regularnych perla, okre¶lonych w polu nazwy
symbolu. Wyra¿enie regularne jest dopasowane "jak jest", nie nale¿y jednak
zapominaæ rozpocz±æ go znakiem \fI^\fP, w przeciwnym wypadku dopasuje ono
dowoln± czê¶æ ³añcucha symbolu rzeczywistego \fInazwa@wersja\fP np.:
.RS
.PP
libdummy.so.1 libdummy1 #MINVER#
 (regex)"^mystack_.*@Base$" 1.0
 (regex|optional)"private" 1.0
.P
Symbole takie jak "mystack_new@Base", :mystack_push@Base",
"mystack_pop@Base" itd. zostan± dopasowane przez pierwszy wzorzec, natomiast
np. "ng_mystack_new@Base" \- nie. Drugi wzorzec dopasuje wszystkie symbole
posiadaj±ce ³añcuch "private" w swych nazwach, a dopasowania odziedzicz±
znacznik \fIoptional\fP z wzorca.
.RE
.P
Podane wy¿ej wzorce proste mog± byæ ³±czone tam, gdzie ma to sens. W takim
przypadku s± one przetwarzane w takiej kolejno¶ci, w jakiej podano znaczniki
np. oba
.PP
 (c++|regex)"^NSA::ClassA::Private::privmethod\ed\e(int\e)@Base" 1.0
 (regex|c++)N3NSA6ClassA7Private11privmethod\edEi@Base 1.0
.P
dopasuj± symbole "_ZN3NSA6ClassA7Private11privmethod1Ei@Base" i
"_ZN3NSA6ClassA7Private11privmethod2Ei@Base". Podczas dopasowywania
pierwszego wzorca, symbol surowy jest najpierw odkodowany jako symbol C++, a
odkodowana nazwa symbolu jest dopasowywana do wyra¿enia regularnego. Z
drugiej strony, gdy dopasowywany jest drugi wzorzec, wyra¿enie regularne
jest dopasowywane do surowej nazwy symbolu, nastêpnie sprawdzane jest, czy
symbol jest symbolem C++ przez próbê odkodowania go. Niepowodzenie ka¿dego
symbolu prostego spowoduje niepowodzenie ca³ego wzorca. Z tego powodu
np. "__N3NSA6ClassA7Private11privmethod\edEi@Base" nie bêdzie pasowaæ do
¿adnego ze wzorców, poniewa¿ nie jest poprawnym symbolem C++.
.P
Ogólnie, wszystkie wzorce s± podzielone na dwie grupy: aliasy (proste \fIc++\fP
i \fIsymver\fP) i wzorce ogólne (\fIregex\fP, wszystkie kombinacje wielu prostych
wzorców). Dopasowanie prostych wzorców opartych na aliasach jest szybkie
(0(1)), a wzorce ogólne maj± 0(N) (N \- liczba wzorców ogólnych) na ka¿dy
symbol. Z tego powodu nie zaleca siê nadu¿ywania wzorców ogólnych.
.P
Gdy wiele symboli pasuje do tego samego symbolu rzeczywistego, aliasy
(najpierw \fIc++\fP, nastêpnie \fIsymver\fP) s± preferowane w stosunku do wzorców
ogólnych. Wzorce ogólne s± dopasowywane w takiej kolejno¶ci, w jakiej
zostan± odnalezione w szablonie pliku symboli, a¿ do pierwszego
sukcesu. Proszê jednak zwróciæ uwagê, ¿e rêczna zmiana kolejno¶ci wpisów
pliku szablonu nie jest zalecana, poniewa¿ \fBdpkg\-gensymbols\fP tworzy diffy w
oparciu o alfanumeryczn± kolejno¶æ ich nazw.
.SS "U¿ywanie include (do³±czeñ)"
.P
Gdy zestaw eksportowanych symboli ró¿ni siê miêdzy architekturami, mo¿e
okazaæ siê, ¿e u¿ywanie pojedynczego pliku symboli nie jest wygodne. W
takich przypadkach, dyrektywa do³±czenia mo¿e okazaæ siê przydatna na kilka
sposobów:
.IP \(bu 4
Mo¿na przenie¶æ czê¶æ wspóln± do pliku zewnêtrznego i do³±czyæ go do swojego
pliku \fIpakiet\fP.symbols.\fIarch\fP u¿ywaj±c dyrektywy do³±czenia podobnej do
poni¿szej:

#include "\fIpakiet\fP.symbols.common"
.IP \(bu
Dyrektywa do³±czenia mo¿e zostaæ otagowana podobnie jak ka¿dy symbol:

(tag|...|tagN)#include "plik\-do\-do³±czenia"

W rezultacie, wszystkie symbole z \fIpliku\-do\-do³±czenia\fP zostan± domy¶lnie
oznaczone przez \fItag\fP ... \fItagN\fP. Mo¿na u¿yæ tej funkcji, aby utworzyæ
wspólny plik \fIpakiet\fP.symbols, który do³±cza pliki symboli specyficzne dla
architektury:

  common_symbol1@Base 1.0
 (arch=amd64 ia64 alpha)#include "package.symbols.64bit"
 (arch=!amd64 !ia64 !alpha)#include "package.symbols.32bit"
  common_symbol2@Base 1.0
.P
Pliki symboli s± czytane wiersz po wierszu, a dyrektywy do³±czenia s±
przetwarzane zaraz po ich wyst±pieniu. Oznacza to, ¿e zawarto¶æ za³±czonego
pliku mo¿e przes³oniæ ka¿d± zawarto¶æ, która pojawi siê przed dyrektyw±
do³±czenia, i ¿e zawarto¶æ po dyrektywie mo¿e przes³oniæ wszystko, co
znajduje siê w do³±czanym pliku. Ka¿dy symbol (lub nawet inna dyrektywa
#include) w do³±czanym pliku mo¿e okre¶liæ dodatkowe znaczniki lub
przes³oniæ warto¶ci dziedziczonych znaczników w ich okre¶leniach
znaczników. Nie ma jednak sposobu, aby symbol usun±æ jakikolwiek z
dziedziczonych znaczników.
.P
Do³±czone pliki mog± powtórzyæ wiersz nag³ówkowy zawieraj±cy SONAME
biblioteki. W takim przypadku, przes³oni on wszystkie odczytane wcze¶niej
wiersze nag³ówkowe. Najlepiej jest jednak zapobiegaæ duplikowaniu wierszy
nag³ówkowych. Oto jeden ze sposobów:
.PP
#include "libsomething1.symbols.common"
 arch_specific_symbol@Base 1.0
.SS "Dobre zarz±dzanie bibliotek±"
.P
Dobrze zarz±dzana biblioteka ma nastêpuj±ce cechy:
.IP \(bu 4
jej API jest stabilne (symbole publiczne nie s± nigdy porzucane, dodawane s±
tylko nowe symbole publiczne), a niekompatybilne zmiany s± wykonywane tylko
przy zmianach SONAME;
.IP \(bu 4
idealnie, u¿ywa wersjonowania symboli, aby osi±gn±æ stabilno¶æ ABI
niezale¿nie od zmian wewnêtrznych i rozszerzeñ API;
.IP \(bu 4
nie eksportuje symboli prywatnych (takie symbole mog± byæ tagowane jako
opcjonalne, jako obej¶cie).
.P
Podczas zarz±dzania plikiem symboli ³atwo jest zauwa¿yæ pojawienie siê lub
znikniêcie symboli. Znacznie trudniej jednak wy³apaæ niekompatybiln± zmianê
API i ABI. W zwi±zku z tym, opiekun pakietu powinien dok³adnie sprawdziæ w
dzienniku zmian projektu macierzystego, czy istnieje przypadek, ¿e zasady
dobrego zarz±dzania bibliotek± zosta³y z³amane. Je¶li odkryje siê
potencjalne problemy, macierzysty autor powinien zostaæ poinformowany, jako
¿e poprawka w projekcie macierzystym jest zawsze lepsza, ni¿ obej¶cie
problemu w samym Debianie.
.SH OPCJE
.TP 
\fB\-P\fP\fIkatalog\-budowania\-pakietu\fP
Przeszukuje \fIkatalog\-budowania\-pakietu\fP zamiast debian/tmp.
.TP 
\fB\-p\fP\fIpakiet\fP
Definiuje nazwê pakietu. Wymagane, je¶li wiêcej ni¿ jeden pakiet binarny
jest wypisany w debian/control (lub nie ma tego pliku).
.TP 
\fB\-v\fP\fIwersja\fP
Definiuje wersjê pakietu. Domy¶lnie jest to wersja wziêta z
debian/changelog. Wymagane, je¶li wywo³anie ma miejsce spoza drzewa pakietu
¼ród³owego.
.TP 
\fB\-e\fP\fIplik\-biblioteki\fP
Only analyze libraries explicitly listed instead of finding all public
libraries. You can use shell patterns used for pathname expansions (see the
\fBFile::Glob\fP(3perl) manual page for details) in \fIlibrary\-file\fP to match
multiple libraries with a single argument (otherwise you need multiple
\fB\-e\fP).
.TP 
\fB\-I\fP\fInazwa\-pliku\fP
U¿ywa \fInazwy\-pliku\fP jako pliku odniesienia do generowania pliku symboli,
który jest integrowany w samym pakiecie.
.TP 
\fB\-O\fP[\fIfilename\fP]
Print the generated symbols file to standard output or to \fIfilename\fP if
specified, rather than to \fBdebian/tmp/DEBIAN/symbols\fP (or
\fIpackage\-build\-dir\fP\fB/DEBIAN/symbols\fP if \fB\-P\fP was used). If \fIfilename\fP is
pre\-existing, its contents are used as basis for the generated symbols
file.  You can use this feature to update a symbols file so that it matches
a newer upstream version of your library.
.TP 
\fB\-t\fP
Write the symbol file in template mode rather than the format compatible
with \fBdeb\-symbols\fP(5). The main difference is that in the template mode
symbol names and tags are written in their original form contrary to the
post\-processed symbol names with tags stripped in the compatibility mode.
Moreover, some symbols might be omitted when writing a standard
\fBdeb\-symbols\fP(5) file (according to the tag processing rules) while all
symbols are always written to the symbol file template.
.TP 
\fB\-c\fP\fI[0\-4]\fP
Definiuje sprawdzenia do wykonania podczas porównywania wygenerowanego pliku
symboli z plikiem szablonu u¿ywanym na pocz±tku. Domy¶lnym poziomem jest
1. Zwiêkszanie poziomu wykonuje wiêcej sprawdzeñ i zawiera wszystkie
sprawdzenia z ni¿szego poziomu. Poziom 0 nigdy nie koñczy siê b³êdem. Poziom
1 sprawdza, czy jakie¶ symbole nie zniknê³y. Poziom 2 zawodzi, gdy
wprowadzono jakie¶ nowe symbole. Poziom 3 zwraca b³±d, gdy zniknê³y jakie¶
biblioteki. Poziom 4 \- gdy wprowadzono biblioteki.

This value can be overridden by the environment variable
\fBDPKG_GENSYMBOLS_CHECK_LEVEL\fP.
.TP 
\fB\-q\fP
Keep quiet and never generate a diff between generated symbols file and the
template file used as starting point or show any warnings about new/lost
libraries or new/lost symbols. This option only disables informational
output but not the checks themselves (see \fB\-c\fP option).
.TP 
\fB\-a\fP\fIarchitektura\fP
Zak³ada \fIarchitekturê\fP jako architekturê hosta w czasie przetwarzania
plików symboli. Opcji mo¿na u¿yæ, aby wygenerowaæ plik symboli lub diff dla
której¶ z architektur, zak³adaj±c ¿e jej pliki binarne s± ju¿ dostêpne.
.TP 
\fB\-d\fP
W³±cza tryb debugowania. Wy¶wietlanych jest wiele komunikatów t³umacz±cych
dzia³anie \fBdpkg\-gensymbols\fP.
.TP 
\fB\-V\fP
W³±cza tryb szczegó³owy. Wygenerowany plik symboli zawiera przestarza³e
symbole jako komentarze. Co wiêcej, w trybie szablonu po wzorcach symboli
wystêpuj± komentarze opisuj±ce symbole rzeczywiste, które dopasowano do
wzorca.
.TP 
\fB\-?\fP, \fB\-\-help\fP
Wy¶wietla informacjê o u¿ytkowaniu i koñczy dzia³anie.
.TP 
\fB\-\-version\fP
Wy¶wietla informacjê o wersji i pomy¶lnie koñczy dzia³anie.
.
.SH "ZOBACZ TAK¯E"
\fBhttps://people.redhat.com/drepper/symbol\-versioning\fP
.br
\fBhttps://people.redhat.com/drepper/goodpractice.pdf\fP
.br
\fBhttps://people.redhat.com/drepper/dsohowto.pdf\fP
.br
\fBdeb\-symbols\fP(5), \fBdpkg\-shlibdeps\fP(1).
.SH T£UMACZE
Piotr Roszatycki <dexter@debian.org>, 1999
.br
Bartosz Feñski <fenio@debian.org>, 2004-2005
.br
Robert Luberda <robert@debian.org>, 2006-2008
.br
Wiktor Wandachowicz <siryes@gmail.com>, 2008
.br
Micha³ Ku³ach <michal.kulach@gmail.com>, 2012
